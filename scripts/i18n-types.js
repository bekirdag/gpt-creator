#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');
const {
  discoverLocaleContexts,
  flattenLocaleTree,
  loadLocaleFile,
  ensureDirSync,
} = require('./i18n-utils.js');

function toSegments(relativeFile) {
  return relativeFile
    .replace(/\\/g, '/')
    .replace(/\.json$/i, '')
    .split('/')
    .filter(Boolean)
    .map((segment) => segment.replace(/[^a-zA-Z0-9]+/g, ' '))
    .map((segment) => segment.trim())
    .filter(Boolean);
}

function toPascalCase(segment) {
  return segment
    .split(' ')
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join('');
}

function toCamelCase(segment) {
  const pascal = toPascalCase(segment);
  return pascal ? pascal.charAt(0).toLowerCase() + pascal.slice(1) : '';
}

function buildTypeDefinitions(definitions, allKeys) {
  const lines = [];
  lines.push('// Auto-generated by scripts/i18n-types.js. Do not edit manually.');
  lines.push('');

  for (const def of definitions) {
    lines.push(`export const ${def.variableName} = [`);
    if (def.keys.length > 0) {
      for (const key of def.keys) {
        lines.push(`  '${key}',`);
      }
    }
    lines.push(`] as const;`);
    lines.push(`export type ${def.typeName} = typeof ${def.variableName}[number];`);
    lines.push('');
  }

  const aggregated = Array.from(allKeys).sort((a, b) => a.localeCompare(b));
  lines.push('export const localeKeys = [');
  for (const key of aggregated) {
    lines.push(`  '${key}',`);
  }
  lines.push('] as const;');
  if (aggregated.length > 0) {
    lines.push('export type LocaleKey = typeof localeKeys[number];');
  } else {
    lines.push('export type LocaleKey = never;');
  }
  lines.push('');

  return `${lines.join('\n')}`;
}

function generateTypesForContext(projectRoot, context) {
  const baseDir = context.baseDir;
  const definitions = [];
  const allKeys = new Set();

  for (const relativeFile of context.baseFiles) {
    const basePath = path.join(baseDir, relativeFile);
    const baseInfo = loadLocaleFile(basePath);
    if (baseInfo.error) {
      throw new Error(`Invalid JSON in ${path.relative(projectRoot, basePath)}: ${baseInfo.error.message}`);
    }
    if (!baseInfo.data || typeof baseInfo.data !== 'object' || Array.isArray(baseInfo.data)) {
      throw new Error(`Locale ${path.relative(projectRoot, basePath)} must export an object.`);
    }
    const keys = flattenLocaleTree(baseInfo.data).map(([key]) => key);
    keys.sort((a, b) => a.localeCompare(b));

    const segments = toSegments(relativeFile);
    const baseName = segments.length > 0 ? segments.join(' ') : 'Locale';
    const typeName = `${toPascalCase(baseName)}Key`;
    const variableBase = toCamelCase(baseName) || 'locale';
    const variableName = `${variableBase}KeyEntries`;

    definitions.push({
      variableName,
      typeName,
      keys,
    });

    for (const key of keys) {
      allKeys.add(key);
    }
  }

  const output = buildTypeDefinitions(definitions, allKeys);
  const srcRoot = path.dirname(context.localesRoot);
  const targetPath = path.join(srcRoot, 'i18n-keys.d.ts');
  ensureDirSync(srcRoot);
  const existing = fs.existsSync(targetPath) ? fs.readFileSync(targetPath, 'utf8') : '';
  if (existing !== output) {
    fs.writeFileSync(targetPath, `${output}`);
    return targetPath;
  }
  return null;
}

function main() {
  const projectRoot = process.cwd();
  const contexts = discoverLocaleContexts(projectRoot);
  if (contexts.length === 0) {
    return 0;
  }
  const written = [];
  for (const context of contexts) {
    try {
      const result = generateTypesForContext(projectRoot, context);
      if (result) {
        written.push(path.relative(projectRoot, result));
      }
    } catch (error) {
      console.error(
        JSON.stringify(
          {
            error: 'i18n-types-failed',
            app: context.appName,
            message: error.message || String(error),
          },
          null,
          2,
        ),
      );
      return 1;
    }
  }

  if (written.length > 0) {
    console.log(
      JSON.stringify(
        {
          updated: written,
        },
        null,
        2,
      ),
    );
  }

  return 0;
}

if (require.main === module) {
  const exitCode = main();
  process.exitCode = exitCode;
}

module.exports = { main };
